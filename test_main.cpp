// let's try this with google test
// includes and such are in /usr/

// Step 1. Include necessary header files such that the stuff your
// test logic needs is declared.
//
// Don't forget gtest.h, which declares the testing framework.

#include <stdio.h>
#include "cribbage_core.h"
#include "card_utils.h"
#include "cribbage_player.h"
#include "gtest/gtest.h"
#include <iostream>
#include <string>
#include "plat_io.h"

using namespace cardutils;
using namespace cribbage_core;

//need some globals in order to use the classes - gross but there it is
CardUtils cu;
Cribbage cr;

namespace {

    // Step 2. Use the TEST macro to define your tests.
    //
    // TEST has two parameters: the test case name and the test name.
    // After using the macro, you should define your test logic between a
    // pair of braces.  You can use a bunch of macros to indicate the
    // success or failure of a test.  EXPECT_TRUE and EXPECT_EQ are
    // examples of such macros.  For a complete list, see gtest.h.

    // TODO: init an array of these uint32s, srand with 9999, expect this sequence from my_random
    //
    // testing random first 10! seeded with 9999 ================================================================

    TEST(CardUtilsTest,VpokRandomFirst10From1337d00d) {
        //vpok random! First 10 are
        uint32_t vrandfirst[10] = { 0xC46EB208, 0xB3C52DC7, 0x661E907A, 0xB576E591, 0x3E1961BC,
            0x0C05D1EB, 0xAA513E4E, 0x57003155, 0x8C6652B0, 0x35C3464F };
        //which agree with my ancient PIC version!
        cu.v_srandom(0x1337d00d);
        for(auto j=0;j<10;j++) {
            EXPECT_EQ(cu.v_random(),vrandfirst[j]);
        }
    }

    //let's do ten million random_at_mosts and see if any wander out of bounds
    //NOT CONCLUSIVE, just checks if the min and max are within the expected min-max range
    //very suggestive, though, if ten million >> expected max
    TEST(CardUtilsTest,RandomAtMost3333TenMReps) {
        uint32_t maxy = 0, minny = 0xFFFFFFFF, expmin = 0, expmax = 3333;
        cu.v_srandom(0x1337d00d);
        for (auto j = 0; j < 10000000; j++) {
            auto x = cu.random_at_most(expmax);
            if (x < minny) minny = x;
            if (x > maxy) maxy = x;
        }
        //plprintf("Minny = %d, maxy = %d\n",minny, maxy);
        EXPECT_LE(maxy,expmax);
        EXPECT_GE(minny,expmin);
    }

    // card basics tests ========================================================================================

    //test that card -> string -> card works for all cards
    TEST(CardUtilsTest,StrcardCardstrAllLegit) {
        std::string cardstr;
        card_t outcard;
        for(card_t card = 0; card < 52; card++) {
            cardstr = cu.cardstring(card);
            outcard = cu.stringcard(cardstr);
            //plprintf("%2d => %s => %2d\n",card,cardstr.c_str(),outcard);
            EXPECT_EQ(card,outcard);
        }
    }

    //*********************************************************************************************************
    //*********************************************************************************************************
    //*********************************************************************************************************
    // HEY DO SOME TESTS WITH NON-LEGIT
    //*********************************************************************************************************
    //*********************************************************************************************************
    //*********************************************************************************************************

    // shuffle test for sameness with python implementation
    TEST(CardUtilsTest,ShuffleTestFrom9999) {
        //generated by python shuffle after random seeded with 9999
        card_t cardorder[52] = { 15, 9, 49, 14, 22, 31, 16, 13, 0, 50, 8, 47, 28, 11, 35, 2, 1, 12, 45, 7, 21, 23, 6, 17, 34, 37,
            4, 41, 36, 40, 32, 38, 51, 19, 39, 46, 27, 10, 29, 26, 48, 33, 20, 30, 3, 44, 24, 42, 18, 25, 43, 5 };
        std::vector<card_t> deck(52);
        cu.v_srandom(9999);
        cu.shuffle(deck);
        for(auto j = 0; j < 52; j++) EXPECT_EQ(deck[j],cardorder[j]);
        //however, we expect the DEAL to be from the right, so it'd go 9, 17, 7, 42, ...
        //in fact let's unit test that
    }

    TEST(CardUtilsTest,Deal10FromShuf9999) {
        card_t dealorder[10] = { 5, 43, 25, 18, 42, 24, 44, 3, 30, 20 };
        std::vector<card_t> deck(52);
        cu.v_srandom(9999);
        cu.shuffle(deck);
        for(auto j = 0; j < 10; j++) {
            EXPECT_EQ(cu.deal_card(deck),dealorder[j]);
            EXPECT_EQ(deck.size(),52-(j+1));            //clunky but sort of readable, deck shrinks by 1 per card dealt
        }
    }

    //test cut: 10 card deck from 10..19, cut at index 6
    // but... now we count from the right? so index 6 is really 6 from the end
    // python semantics are now consistent
    TEST(CardUtilsTest,DeckCutTest) {
        card_t postcut_deck[10] = {14, 15, 16, 17, 18, 19, 10, 11, 12, 13 };
        std::vector<card_t> deck;
        deck.reserve(52);
        for(auto j=0;j<10;j++) deck.push_back(10+j);
        cu.cut(deck,6);
        for(auto j=0;j<10;j++) EXPECT_EQ(deck[j],postcut_deck[j]);
   }



   // now for actual cribbage tests! Here, scoring shew.
   // let's make a fixture, bc we will want a Cribbage for each as well as a hand and a starter and a score list
    class ScoreShowTest : public ::testing::Test {
        protected:

        // data members
        uint32_t default_seed = 0x1337d00d;
        std::vector<card_t> hand;
        card_t starter;
        std::vector<Cribbage::score_entry> scorelist;
        bool build_scorelists = true;      //FOR SPEED TESTING WITH OR WITHOUT BUILDING SCORELISTS

        //special helper function to create a hand - give it string reps of 5 cards
        //and the first 4 become "hand" global and last becomes starter
        void build_hand(std::string h1, std::string h2, std::string h3, std::string h4, std::string st) {
            hand.clear();
            hand.push_back(cu.stringcard(h1));
            hand.push_back(cu.stringcard(h2));
            hand.push_back(cu.stringcard(h3));
            hand.push_back(cu.stringcard(h4));
            starter = cu.stringcard(st);
            //check for illegal cards
            if(hand[0] == cu.ERROR_CARD_VAL) plprintf("WARNING: card 1 is illegal string '%s'\n",h1.c_str());
            if(hand[1] == cu.ERROR_CARD_VAL) plprintf("WARNING: card 2 is illegal string '%s'\n",h2.c_str());
            if(hand[2] == cu.ERROR_CARD_VAL) plprintf("WARNING: card 3 is illegal string '%s'\n",h3.c_str());
            if(hand[3] == cu.ERROR_CARD_VAL) plprintf("WARNING: card 4 is illegal string '%s'\n",h4.c_str());
            if(starter == cu.ERROR_CARD_VAL) plprintf("WARNING: starter is illegal string '%s'\n",st.c_str());
        }

        void render_shew_scorelist() {
            index_t mask;
            plprintf("score list: -----------------\n");
            for(auto j = 0; j < 4; j++) plprintf("%s ",cu.cardstring(hand[j]).c_str());
            plprintf("%s ",cu.cardstring(starter).c_str());
            plprintf(" hand\n");
            index_t totscore = 0;
            for (Cribbage::score_entry se : scorelist) {
                for(auto j = 0,mask = 0x01; j < 5; j++, mask <<= 1)
                    if(se.part_cards & mask)
                        if(j<4)
                            plprintf("%s ",cu.cardstring(hand[j]).c_str());
                        else
                            plprintf("%s ",cu.cardstring(starter).c_str());
                    else plprintf("-- ");
                totscore += cr.scorePoints[se.score_index];
                plprintf(" %s %d (%d)\n",cr.scoreStrings[se.score_index].c_str(),cr.scorePoints[se.score_index],totscore);
            }
        }

        // setup initializes data members, runs BEFORE EVERY TEST
        void SetUp() override {
            cu.v_srandom(default_seed);
            //I think the longest possible list of scores is for 29: eight fifteens + 4 of a kind + nobs?
            //VERIFY
            scorelist.reserve(10);
        }

        // teardown cleans up after data members, runs AFTER EVERY TEST
        void TearDown() override {

        }

    };


    //all right! set up a hand that should have no scoring combinations in it and score it! Expect a score of 0
    TEST_F(ScoreShowTest,T000_Nothing) {
        build_hand("Qh", "0c", "9s", "3d","4d");
        //this should be the longest-running scoring case - let's try 10 million of them
        //20963 ms debug, 1115 ms release - not bad!
        index_t handscore;
        //for(auto j=0;j<10000000;j++)
            handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,0);
        if(build_scorelists) render_shew_scorelist();
    }

    //all right! set up a hand that should have two two-card fifteens in it and score it! Expect a score of 4
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T010_TwoCardFifteen) {
        build_hand("Qh", "0c", "9s", "3d","5d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_FIFTEEN]*2);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have two 3-card fifteens! Expect a score of 4
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T020_ThreeCardFifteen) {
        build_hand("6h", "3c", "7s", "0d","2d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_FIFTEEN]*2);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have one 4-card fifteen in it! Expect a score of 2
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T030_FourCardFifteen) {
        build_hand("Ah", "4c", "3s", "7d","6d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_FIFTEEN]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have one 5-card fifteen and a run of 5 in it! Expect a score of 7
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T040_FiveCardFifteen) {
        build_hand("Ah", "4c", "3s", "5d","2d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_FIFTEEN] + cr.scorePoints[Cribbage::SCORE_RUN5]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have one pair in it! Expect a score of 2
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T050_OnePair) {
        build_hand("Ah", "2c", "6s", "0d","Ad");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_PAIR]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have two pairs in it! Expect a score of 4
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T060_TwoPair) {
        build_hand("Ah", "0c", "6s", "0d","Ad");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_TWOPAIR]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have a 3 of a kind in it! Expect a score of 6
    //LATER will check for detailed results
    // ... for how these are spotted, rank shouldn't matter, but still
    //3 of a kind is the lowest rank
    //Instead do tests re: where they are in the hand
    TEST_F(ScoreShowTest,T070_ThreeOfAKindLow) {
        build_hand("Ah", "Ac", "6s", "0d","Ad");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_PAIRROYAL]);
        if(build_scorelists) render_shew_scorelist();
    }

    //3 of a kind is the middle rank
    TEST_F(ScoreShowTest,T073_ThreeOfAKindMid) {
        build_hand("6s", "7c", "0h", "7h","7d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_PAIRROYAL]);
        if(build_scorelists) render_shew_scorelist();
    }

    //3 of a kind is the highest rank
    TEST_F(ScoreShowTest,T077_ThreeOfAKindHigh) {
        build_hand("0d", "6s", "Kc", "Kh","Kd");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_PAIRROYAL]);
        if(build_scorelists) render_shew_scorelist();
    }


    //should have a 3 of a kind in it plus another pair! Expect a score of 8
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T080_ThreeOfAKindAndPairLow) {
        build_hand("Ah", "Ac", "4s", "4d","Ad");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_PAIRROYAL]+cr.scorePoints[Cribbage::SCORE_PAIR]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T085_ThreeOfAKindAndPairHigh) {
        build_hand("Kh", "Kc", "4s", "4d","Kd");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_PAIRROYAL]+cr.scorePoints[Cribbage::SCORE_PAIR]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have a 4 of a kind in it! Expect a score of 12
    //LATER will check for detailed results
    //this one tests if the 4 of a kind is the higher rank compared to the odd card out
    //because of how the 4s of a kind are spotted, with patterns, this needs to be tested as well as if
    //the 4 of a kind is the lower rank (see next test.)
    TEST_F(ScoreShowTest,T090_FourOfAKindHigh) {
        build_hand("4c", "Ac", "4s", "4h","4d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_4KIND]);
        if(build_scorelists) render_shew_scorelist();
    }

    //lower rank compared to the odd card out
    TEST_F(ScoreShowTest,T095_FourOfAKindLow) {
        build_hand("4c", "Jc", "4s", "4h","4d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_4KIND]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have a run of 3 in it! Expect a score of 3
    //LATER will check for detailed results
    //this one tests if the run of 3 is the first 3 cards
    //because of how the runs are spotted, with patterns, this needs to be tested as well as if
    //the run of 3 is the second or third triplet
    TEST_F(ScoreShowTest,T100_RunOfThreeLow) {
        build_hand("8c", "9c", "0s", "Qh","Kd");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_RUN3]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T103_RunOfThreeMid) {
        build_hand("Ac", "9c", "0s", "Jh","Kd");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_RUN3]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T107_RunOfThreeHigh) {
        build_hand("2c", "4c", "Js", "Qh","Kd");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_RUN3]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have a run of 4 in it! Expect a score of 8 bc there are a couple of 15s in there too
    //LATER will check for detailed results
    //this one tests if the run of 4 is the first 4 cards
    //because of how the runs are spotted, with patterns, this needs to be tested as well as if
    //the run of 4 is the second set of 4
    TEST_F(ScoreShowTest,T110_RunOfFourLow) {
        build_hand("Ac", "3c", "4s", "Qh","2d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_RUN4] + (2* cr.scorePoints[Cribbage::SCORE_FIFTEEN]));
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T120_RunOfFourHigh) {
        build_hand("0c", "Jc", "Ks", "Qh","2d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_RUN4]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have a run of 5 in it! Expect a score of 5
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T130_RunOfFive) {
        build_hand("9c", "Kc", "Js", "Qh","0d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_RUN5]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have a double run of 3 in it! Expect a score of 8
    //this one checks for double run of 3 where the pair is the lowest rank
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T140_DblRunThreeLow) {
        build_hand("8c", "8c", "9s", "Qh","0d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_DBLRUN3]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T143_DblRunThreeMid) {
        build_hand("8c", "9c", "9s", "Qh","0d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_DBLRUN3]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T147_DblRunThreeHigh) {
        build_hand("8c", "0c", "9s", "Qh","0d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_DBLRUN3]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have a double run of 3 in it! Expect a score of 10
    //this one checks for double run of 4 where the pair is the lowest rank
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T150_DblRunFourLowest) {
        build_hand("8c", "8s", "9s", "Jh","0d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_DBLRUN4]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T153_DblRunFourLowmid) {
        build_hand("8c", "9c", "9s", "Jh","0d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_DBLRUN4]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T155_DblRunFourHighmid) {
        build_hand("8c", "0c", "9s", "Jh","0d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_DBLRUN4]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T157_DblRunFourHigh) {
        build_hand("8c", "Jc", "9s", "Jh","0d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_DBLRUN4]);
        if(build_scorelists) render_shew_scorelist();
    }


    //should have a double double run of 3 in it! Expect a score of 16
    //this one checks for double double run of 3 where the pairs are the lowest rank and highest
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T160_DblDblRunLowHigh) {
        build_hand("8c", "8s", "0s", "0h","9d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_DBLDBLRUN]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T163_DblDblRunLowMid) {
        build_hand("8c", "9d", "9s", "0h","8d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_DBLDBLRUN]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T160_DblDblRunMidHigh) {
        build_hand("8c", "9h", "9s", "0h","0d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_DBLDBLRUN]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have a triple run of 3 in it! Expect a score of 15
    //this one checks for triple run of 3 where the 3 of a kind is lowest rank
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T170_TripleRunLow) {
        build_hand("9h", "9c", "0s", "Js","9d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_TRIPLERUN]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T173_TripleRunMid) {
        build_hand("0h", "0c", "9s", "0d","Jc");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_TRIPLERUN]);
        if(build_scorelists) render_shew_scorelist();
    }

    TEST_F(ScoreShowTest,T177_TripleRunHigh) {
        build_hand("6h", "7h", "5s", "7d","7c");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_TRIPLERUN]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have a 4 card flush in it! Expect a score of 4
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T180_FourCardFlush) {
        build_hand("4c", "3c", "Jc", "7c","9h");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_FLUSH]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have a 5 card flush in it! Expect a score of 5
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T190_FiveCardFlush) {
        build_hand("4c", "3c", "Qc", "7c","9c");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_FLUSH5]);
        if(build_scorelists) render_shew_scorelist();
    }

    //should NOT have a 4 card flush in it! bc the 4 cards include starter Expect a score of 0
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T200_NotFourCardFlush) {
        build_hand("4c", "3c", "Kc", "7h","9c");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,0);
        if(build_scorelists) render_shew_scorelist();
    }

    //should have nobs in it! Expect a score of 1
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T210_Nobs) {
        build_hand("Qh", "Jd", "9s", "3d","4d");
        index_t handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,cr.scorePoints[Cribbage::SCORE_NOBS]);
        if(build_scorelists) render_shew_scorelist();
    }


    //should have a 29 hand in it! Expect a score of 29
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T220_Twentynine) {
        build_hand("5c", "5d", "Jh", "5s","5h");
        index_t handscore;
        //I think this might be the slowest case for scoring, so let's try 10 million of it
        //actually no 4 of a kind is a short-circuit, try one with 5 5 5 j j incl nobs
        //plprintf("TEN MILLION!!!\n");
        //for (auto j = 0; j < 10000000; j++)
            handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,(cr.scorePoints[Cribbage::SCORE_FIFTEEN] * 8) +
            cr.scorePoints[Cribbage::SCORE_4KIND] + cr.scorePoints[Cribbage::SCORE_NOBS]);
        if(build_scorelists) render_shew_scorelist();
    }

    //Here trying to find the worst case hand for scoring time. Current guess, 5 5 5 j j with a nobs
    //Expect a score of 15-14 + 3 of a kind + pair + nobs = 23
    //wow, 20.1 seconds debug, but only 900 ms release!
    //if clock speed were the only diffie bt takkun and samd21, ~52 times slower = a long time in debug
    //and ~47 sec release, not horrible considering
    //LATER will check for detailed results
    TEST_F(ScoreShowTest,T230_SlowestScore) {
        build_hand("5c", "5d", "Jh", "Js","5h");
        index_t handscore;
        //I think this might be the slowest case for scoring, so let's try 10 million of it
        //actually no 4 of a kind is a short-circuit, try one with 5 5 5 j j incl nobs
        //plprintf("TEN MILLION!!!\n");
        //for (auto j = 0; j < 10000000; j++)
            handscore = cr.score_shew(hand,starter,&scorelist,build_scorelists);
        EXPECT_EQ(handscore,(cr.scorePoints[Cribbage::SCORE_FIFTEEN] * 7) +
            cr.scorePoints[Cribbage::SCORE_PAIRROYAL] + cr.scorePoints[Cribbage::SCORE_PAIR] + cr.scorePoints[Cribbage::SCORE_NOBS]);
        if(build_scorelists) render_shew_scorelist();
    }


    //then a fixture for play_card test
    class PlayCardTest : public ::testing::Test {
        protected:

        // data members
        uint32_t default_seed = 0x1337d00d;
        std::vector<card_t> cardstack;
        card_t card;
        std::vector<Cribbage::score_entry> scorelist;
        bool build_scorelists = true;      //FOR SPEED TESTING WITH OR WITHOUT BUILDING SCORELISTS

        //special helper function to create a card stack - give it string reps cards
        //they become cardstack "global"
        void build_stack(std::vector<std::string> stackcardsstr) {
            cardstack.clear();
            for (auto j = 0; j < stackcardsstr.size(); j++)
                cardstack.push_back(cu.stringcard(stackcardsstr[j]));
            //check for illegal cards
            for(auto j = 0; j < cardstack.size(); j++)
                if(cardstack[j] == cu.ERROR_CARD_VAL) plprintf("WARNING: stack card %d is illegal string '%s'\n",j,stackcardsstr[j].c_str());
        }

        //cardstack should have the played card on it
        void render_play_scorelist(std::vector<std::string> stackcardsstr, std::string cardstr) {
            index_t mask;
            plprintf("score list: -----------------\n");
            if(stackcardsstr.empty())
                plprintf("empty ");
            else
                for(index_t j = 0; j< stackcardsstr.size(); j++) plprintf("%s ",stackcardsstr[j].c_str());
            //plprintf("%s ",cu.cardstring(starter).c_str());
            plprintf("stack, played %s\n",cardstr.c_str());
            index_t totscore = 0;
            for (Cribbage::score_entry se : scorelist) {
                //remember the early cards are rightmost
                for(index_t j = 0,mask = 1 << cardstack.size(); j < cardstack.size(); j++, mask >>= 1)
                    if(se.part_cards & mask)
                        plprintf("%s ",cu.cardstring(cardstack[j]).c_str());
                    else plprintf("-- ");
                totscore += cr.scorePoints[se.score_index];
                plprintf(" %s %d (%d)\n",cr.scoreStrings[se.score_index].c_str(),cr.scorePoints[se.score_index],totscore);
            }
        }

        // setup initializes data members, runs BEFORE EVERY TEST
        void SetUp() override {
            cu.v_srandom(default_seed);
            //I think the longest possible list of scores is for 29: eight fifteens + 4 of a kind + nobs?
            //VERIFY
            scorelist.reserve(10);
        }

        // teardown cleans up after data members, runs AFTER EVERY TEST
        void TearDown() override {

        }

    };

    // play a card that'll go over 31
    TEST_F(PlayCardTest,T0000_Illegal) {
        //order in which they're played so stack will show it same bc it grows left to right
        std::vector<std::string> startstack = {"Qh", "0c", "9s", "Ad"};
        std::string cardstr = "0d";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        EXPECT_EQ(playscore,cr.ERROR_SCORE_VAL);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    //all right! set up a hand that should have no scoring combinations in it and score it! Expect a score of 0
    TEST_F(PlayCardTest,T000_Nothing) {
        //order in which they're played so stack will show it same bc it grows left to right
        std::vector<std::string> startstack = {"Qh", "8c", "4s", "3d"};
        std::string cardstr = "4d";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        //for(auto j=0;j<10000000;j++)
            playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,0);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T001_Firstcard) {
        //order in which they're played so stack will show it same bc it grows left to right
        std::vector<std::string> startstack = {};
        std::string cardstr = "7h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,0);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T003_Fifteen) {
        //order in which they're played so stack will show it same bc it grows left to right
        std::vector<std::string> startstack = {"5d"};
        std::string cardstr = "Jh";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_FIFTEEN]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T007_Thirtyone) {
        //order in which they're played so stack will show it same bc it grows left to right
        std::vector<std::string> startstack = {"5d","Jh","Ac","5h"};
        std::string cardstr = "Qh";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_THIRTYONE]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T010_Pair) {
        std::vector<std::string> startstack = {"3d"};
        std::string cardstr = "3h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_PAIR]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T020_NotPair) {
        std::vector<std::string> startstack = {"2c"};
        std::string cardstr = "7s";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,0);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T030_3OfAKind) {
        std::vector<std::string> startstack = {"4c","4s"};
        std::string cardstr = "4h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_PAIRROYAL]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T040_Not3OfAKind) {
        std::vector<std::string> startstack = {"4c","Qd","4s"};
        std::string cardstr = "4h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_PAIR]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T050_4OfAKind) {
        std::vector<std::string> startstack = {"Ad","6c","6s","6d"};
        std::string cardstr = "6h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_4KIND]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T060_Not4OfAKind) {
        std::vector<std::string> startstack = {"2c","2d","Qd","2s"};
        std::string cardstr = "2h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_PAIR]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T070_RunOf3) {
        std::vector<std::string> startstack = {"Ac","2s"};
        std::string cardstr = "3h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_RUN3]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T080_RunOf3OOO) {
        std::vector<std::string> startstack = {"8c","6s"};
        std::string cardstr = "7h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_RUN3]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T090_RunOf3intervening) {
        std::vector<std::string> startstack = {"5c","6s","Jd"};
        std::string cardstr = "7h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,0);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    //# TODO HEY DO THIS ONE from http://cribbagecorner.com/cribbage-rules-play
    //#
    //#scoring sequence in play
    //#Submitted by Meade (not verified) on Tue, 04/06/2010 - 01:50.
    //#
    //#How do you score the following sequence made in play? A 7 was played first followed by a 9 and then a 8 to make a
    //# sequence of three for 3 points. Here is the questions: My playing partner then played a 7. Is this another sequence
    //# of three for 3 points and 2 points for 31?
    //#
    //#re: scoring sequence
    //#Submitted by Joan (not verified) on Thu, 06/24/2010 - 17:44.
    //#
    //#Yes, your parntner gets 3 points for the run of 7, 8, 9, the last 3 cards played where the sequence was not broken.
    //# And the 2 points for 31. If 8 or 9 were played first your partner would be out of luck because the first 7 played
    //# would have interrupted the second sequence.

    TEST_F(PlayCardTest,T100_RunOf4) {
        std::vector<std::string> startstack = {"Ac","2s","3s"};
        std::string cardstr = "4h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_RUN4]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T110_RunOf4OOO) {
        std::vector<std::string> startstack = {"8c","6s","5c"};
        std::string cardstr = "7h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_RUN4]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T120_RunOf4intervening) {
        std::vector<std::string> startstack = {"Ac","2s","Jd","3h"};
        std::string cardstr = "4c";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,0);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T130_RunOf5) {
        std::vector<std::string> startstack = {"2c","3s","4s","5d"};
        std::string cardstr = "6h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_RUN5]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T140_RunOf5OOO) {
        std::vector<std::string> startstack = {"8c","6s","5c","4d"};
        std::string cardstr = "7h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_RUN5]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T150_RunOf5intervening) {
        std::vector<std::string> startstack = {"Ac","2s","4c","Jd","3h"};
        std::string cardstr = "5c";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,0);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T160_RunOf6) {
        std::vector<std::string> startstack = {"2c","3s","4s","5d","6h"};
        std::string cardstr = "7h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_RUN6]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T170_RunOf6OOO) {
        std::vector<std::string> startstack = {"3c","6s","5c","4d","2c"};
        std::string cardstr = "7h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_RUN6]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T180_RunOf6intervening) {
        std::vector<std::string> startstack = {"Ac","2s","4c","3d","3h","5d"};
        std::string cardstr = "6c";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,0);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }


    TEST_F(PlayCardTest,T190_RunOf7) {
        std::vector<std::string> startstack = {"Ad","Ah,","2c","3s","4s","5d","6d"};
        std::string cardstr = "7h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        plprintf("Cardstack len now %lu\n",cardstack.size());

        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_RUN7]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T200_RunOf7OOO) {
        std::vector<std::string> startstack = {"7c","6s","5c","4d","2d","3h"};
        std::string cardstr = "Ah";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        //this should be the slowest scoring hand for the play, yes?
        //hm, can't just do it ten million times, I guess - move this earlier? bc cardstack changes
        //so the time is a bit skewed - or maybe just pop that card off cardstack & swh
        //in any case, play scoring is pretty fast, like 3 sec for 10MM in debug
        //plprintf("TEN MILLION!!!\n");
        //for (auto j = 0; j < 10000000; j++)
            playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
            //cardstack.pop_back();
        plprintf("Cardstack len now %lu\n",cardstack.size());
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_RUN7]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T210_RunOf7intervening) {
        std::vector<std::string> startstack = {"3c","2s","Ac","4d","5h","6d"};
        std::string cardstr = "Ac";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,0);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T220_15and3Kind) {
        std::vector<std::string> startstack = {"3d","4c","4s"};
        std::string cardstr = "4h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_FIFTEEN] + cr.scorePoints[Cribbage::SCORE_PAIRROYAL]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T230_31And4Kind) {
        std::vector<std::string> startstack = {"3c","7s","7c","7d"};
        std::string cardstr = "7h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_THIRTYONE] + cr.scorePoints[Cribbage::SCORE_4KIND]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    TEST_F(PlayCardTest,T220_15andRun5) {
        std::vector<std::string> startstack = {"2d","Ac","5s","3d"};
        std::string cardstr = "4h";
        build_stack(startstack);
        card = cu.stringcard(cardstr);
        index_t playscore;
        playscore = cr.play_card(cardstack,card,&scorelist,build_scorelists);
        // HEY PUT IN DETAILED CHECKS a la
        // self.assertEqual(resultcards,curcards + [newcard])
        // self.assertEqual(curtotal,sum([pyb.val(x) for x in curcards]) + pyb.val(newcard))
        // self.assertEqual(scorelist,[(pyb.SCORE_RUN4,4)])
        EXPECT_EQ(playscore,cr.scorePoints[Cribbage::SCORE_FIFTEEN] + cr.scorePoints[Cribbage::SCORE_RUN5]);
        if(build_scorelists) render_play_scorelist(startstack,cardstr);
    }

    //then a fixture for default player tests
    class DefaultPlayerTest : public ::testing::Test {
        protected:

        // data members
        uint32_t default_seed = 0x1337d00d;
        std::vector<card_t> cardstack;
        std::vector<card_t> hand;
        card_t starter;
        card_t card;
        std::vector<Cribbage::score_entry> play_scorelist;
        std::vector<Cribbage::score_entry> shew_scorelist;
        bool build_scorelists = true;      //FOR SPEED TESTING WITH OR WITHOUT BUILDING SCORELISTS

        //special helper function to create a hand - give it string reps of 5 cards
        //and the first 4 become "hand" global and last becomes starter
        void build_hand(std::string h1, std::string h2, std::string h3, std::string h4, std::string st) {
            hand.clear();
            hand.push_back(cu.stringcard(h1));
            hand.push_back(cu.stringcard(h2));
            hand.push_back(cu.stringcard(h3));
            hand.push_back(cu.stringcard(h4));
            starter = cu.stringcard(st);
            //check for illegal cards
            if(hand[0] == cu.ERROR_CARD_VAL) plprintf("WARNING: card 1 is illegal string '%s'\n",h1.c_str());
            if(hand[1] == cu.ERROR_CARD_VAL) plprintf("WARNING: card 2 is illegal string '%s'\n",h2.c_str());
            if(hand[2] == cu.ERROR_CARD_VAL) plprintf("WARNING: card 3 is illegal string '%s'\n",h3.c_str());
            if(hand[3] == cu.ERROR_CARD_VAL) plprintf("WARNING: card 4 is illegal string '%s'\n",h4.c_str());
            if(starter == cu.ERROR_CARD_VAL) plprintf("WARNING: starter is illegal string '%s'\n",st.c_str());
        }


        //special helper function to create a card stack - give it string reps cards
        //they become cardstack "global"
        void build_stack(std::vector<std::string> stackcardsstr) {
            cardstack.clear();
            for (auto j = 0; j < stackcardsstr.size(); j++)
                cardstack.push_back(cu.stringcard(stackcardsstr[j]));
            //check for illegal cards
            for(auto j = 0; j < cardstack.size(); j++)
                if(cardstack[j] == cu.ERROR_CARD_VAL) plprintf("WARNING: stack card %d is illegal string '%s'\n",j,stackcardsstr[j].c_str());
        }

        void render_shew_scorelist() {
            index_t mask;
            plprintf("score list: -----------------\n");
            for(auto j = 0; j < 4; j++) plprintf("%s ",cu.cardstring(hand[j]).c_str());
            plprintf("%s ",cu.cardstring(starter).c_str());
            plprintf(" hand\n");
            index_t totscore = 0;
            for (Cribbage::score_entry se : shew_scorelist) {
                for(auto j = 0,mask = 0x01; j < 5; j++, mask <<= 1)
                    if(se.part_cards & mask)
                        if(j<4)
                            plprintf("%s ",cu.cardstring(hand[j]).c_str());
                        else
                            plprintf("%s ",cu.cardstring(starter).c_str());
                    else plprintf("-- ");
                totscore += cr.scorePoints[se.score_index];
                plprintf(" %s %d (%d)\n",cr.scoreStrings[se.score_index].c_str(),cr.scorePoints[se.score_index],totscore);
            }
        }

        //cardstack should have the played card on it
        void render_play_scorelist(std::vector<std::string> stackcardsstr, std::string cardstr) {
            index_t mask;
            plprintf("score list: -----------------\n");
            if(stackcardsstr.empty())
                plprintf("empty ");
            else
                for(index_t j = 0; j< stackcardsstr.size(); j++) plprintf("%s ",stackcardsstr[j].c_str());
            //plprintf("%s ",cu.cardstring(starter).c_str());
            plprintf("stack, played %s\n",cardstr.c_str());
            index_t totscore = 0;
            for (Cribbage::score_entry se : play_scorelist) {
                //remember the early cards are rightmost
                for(index_t j = 0,mask = 1 << cardstack.size(); j < cardstack.size(); j++, mask >>= 1)
                    if(se.part_cards & mask)
                        plprintf("%s ",cu.cardstring(cardstack[j]).c_str());
                    else plprintf("-- ");
                totscore += cr.scorePoints[se.score_index];
                plprintf(" %s %d (%d)\n",cr.scoreStrings[se.score_index].c_str(),cr.scorePoints[se.score_index],totscore);
            }
        }

        // setup initializes data members, runs BEFORE EVERY TEST
        void SetUp() override {
            cu.v_srandom(default_seed);
            //I think the longest possible list of scores is for 29: eight fifteens + 4 of a kind + nobs?
            //VERIFY
            shew_scorelist.reserve(10);
            // there are really only 3 possible scores in play - 15, pairs & variants, and runs, but reserve 10 why not
            play_scorelist.reserve(10);
        }

        // teardown cleans up after data members, runs AFTER EVERY TEST
        void TearDown() override {

        }
    };

    TEST_F(DefaultPlayerTest,T0_Setup) {
        CribbagePlayer cp;
        EXPECT_EQ(cp.is_dealer(),false);
        EXPECT_EQ(cp.get_name(),"");
        EXPECT_EQ(cp.get_score(),0);
        EXPECT_EQ(cp.get_cards().capacity(),6);
        EXPECT_EQ(cp.get_used_cards().capacity(),4);
        EXPECT_EQ(cp.get_crib().capacity(),4);
        EXPECT_EQ(cp.get_cards().empty(), true);
        EXPECT_EQ(cp.get_used_cards().empty(), true);
        EXPECT_EQ(cp.get_crib().empty(), true);
    }

}

int main(int argc, char *argv[]) {
    //silly noodles
    /*
    std::vector <card_t> stacky;
    stacky.push_back(cu.stringcard("9c"));
    stacky.push_back(cu.stringcard("2h"));
    stacky.push_back(cu.stringcard("7d"));
    stacky.push_back(cu.stringcard("4c"));
    cr.play_card(stacky, cu.stringcard("6c"), nullptr, false);
    */

    /*
    std::vector<card_t> hand;
    hand.push_back(31);
    hand.push_back(17);
    hand.push_back(41);
    hand.push_back(51);
    card_t starter = 44;
    plprintf("Hand: ");
    std::for_each(hand.begin(),hand.end(),[](card_t c){plprintf("%d ",c);});
    plprintf("Starter: %d\n",starter);
    std::array<card_t,5> whole_hand;
    std::array<card_t,5> whole_vals;
    std::array<card_t,5> sorthand_nranks;
    std::array<card_t,5> whole_suits;
    std::array<index_t,5> sort_map;
    //try a bunch of reps to see how long it takes - v. roughly 3 sec for ten million iterations, not great
    //BUT in the context of a giant AI search or whatever, not terrible; minimax is unlikely to be doing that many
    //at least if I limit the deepening
    //oh wait that was on debug, how about release? pretty much insty
    //plprintf("TEN MILLION!!!!\n");
    //for(auto j = 0; j < 10000000; j++)
        c.prep_score_hand(hand, starter, whole_hand, whole_vals, sorthand_nranks, whole_suits, sort_map, true );
    plprintf("Whole Hand: ");
    std::for_each(whole_hand.begin(),whole_hand.end(),[](card_t c){plprintf("%d ",c);});
    plprintf("\nWhole Vals: ");
    std::for_each(whole_vals.begin(),whole_vals.end(),[](card_t c){plprintf("%d ",c);});
    plprintf("\nWhole Hand Suits: ");
    std::for_each(whole_suits.begin(),whole_suits.end(),[](card_t c){plprintf("%d ",c);});
    plprintf("\nSortHand NormRanks: ");
    std::for_each(sorthand_nranks.begin(),sorthand_nranks.end(),[](card_t c){plprintf("%d ",c);});
    //HEY PRINT SORT MAPPING HERE IF WE DID IT
    plprintf("\nSort Map: ");
    std::for_each(sort_map.begin(),sort_map.end(),[](index_t c){plprintf("%d ",c);});
    plprintf("\n");

    //4-carders
    std::array<card_t,4> first4;
    std::array<card_t,4> last4;
    card_t firstlastrank = sorthand_nranks[1];     //first rank of last 4 cards
    std::copy_n(sorthand_nranks.begin(),4,first4.begin());
    std::transform(sorthand_nranks.begin() + 1,sorthand_nranks.end(),last4.begin(),
        [firstlastrank](card_t rank) -> card_t { return rank - firstlastrank; });
    plprintf("First 4 nranks: ");
    std::for_each(first4.begin(),first4.end(),[](card_t c){plprintf("%d ",c);});
    plprintf("\nLast 4 nranks, firstlastrank %d: ",firstlastrank);
    std::for_each(last4.begin(),last4.end(),[](card_t c){plprintf("%d ",c);});
    plprintf("\n");
    */

    // real testing main starts here
    ::testing::InitGoogleTest();
    auto testresult = RUN_ALL_TESTS();
}
