// let's try this with google test
// includes and such are in /usr/

// Step 1. Include necessary header files such that the stuff your
// test logic needs is declared.
//
// Don't forget gtest.h, which declares the testing framework.

#include <stdio.h>
#include "cribbage_cpp.h"
#include "gtest/gtest.h"

using namespace cribbage_cpp;

namespace {

    // Step 2. Use the TEST macro to define your tests.
    //
    // TEST has two parameters: the test case name and the test name.
    // After using the macro, you should define your test logic between a
    // pair of braces.  You can use a bunch of macros to indicate the
    // success or failure of a test.  EXPECT_TRUE and EXPECT_EQ are
    // examples of such macros.  For a complete list, see gtest.h.

    // TODO: init an array of these uint32s, srand with 9999, expect this sequence from my_random
    //
    // testing random first 10! seeded with 9999 ================================================================
    TEST(CribbageTest,RandomFirst10From9999) {
        //first 10 random numbers generated by python version
        uint32_t randfirst[10] = { 168053193, 529018946, 639126842, 91631200, 299803501,
            800805445, 857098366, 2079416933, 611521653, 2135171076 };
        my_srandom(9999);
        for(auto j = 0; j < 10; j++) {
            EXPECT_EQ(my_random(),randfirst[j]);
        }
    }

    // card basics tests ========================================================================================

    //test that card -> string -> card works for all cards
    TEST(CribbageTest,StrcardCardstrAllLegit) {
        char cardstr[3] = { 0,0,0 };
        uint8_t outcard;

        for(uint8_t card = 0; card < 52; card++) {
            cardstring(card,cardstr,0);
            outcard = stringcard(cardstr,0);
            //printf("%2d => %s => %2d\n",card,cardstr,outcard);
            EXPECT_EQ(card,outcard);
        }
    }

    // DO THIS: C++ version is a lot more restrictive than python one tho
    //class StrcardTestAllLegit(unittest.TestCase):
    //    def test_strcard_legit(self):
    //        # test that all upper and lowercase variations of rank and suit match the expected card 0..51
    //        pyb = pybbage.Pybbage()
    //        ranks = 'A234567890JQK'
    //        suits = 'HDCS'
    //        suits2 = '♥♦♣♠'
    //        numgood = 0
    //        for j in range(0,52):
    //            rankchar = ranks[j//4]
    //            ranklchar = str.lower(rankchar)
    //            suitchar = suits[j%4]
    //            suitlchar = str.lower(suitchar)
    //            suit2char = suits2[j%4]
    //            if pyb.stringcard(rankchar+suitchar) == j and pyb.stringcard(rankchar+suit2char) == j and \
    //                pyb.stringcard(ranklchar+suitchar) == j and pyb.stringcard(ranklchar+suit2char) == j and \
    //                pyb.stringcard(ranklchar + suitlchar) == j and pyb.stringcard(rankchar+suitlchar) == j:
    //                numgood += 1
    //        self.assertEqual(numgood,52)

    //DO THIS: adjusting suits2 to "hdcs"
    //class CardstrTestAllLegit(unittest.TestCase):
    //    def test_cardstr_legit(self):
    //        pyb = pybbage.Pybbage()
    //        # test that all values for card 0..51 get back the correct rank and suit
    //        ranks = 'A234567890JQK'
    //        suits2 = '♥♦♣♠'
    //        numgood = 0
    //        for j in range(0,52):
    //            if pyb.cardstring(j) == ranks[pyb.rank(j)] + suits2[pyb.suit(j)]:
    //                numgood += 1
    //        self.assertEqual(numgood,52)

    // shuffle test for sameness with python implementation
    TEST(CribbageTest,ShuffleTestFrom9999) {
        //generated by python shuffle after random seeded with 9999
        uint8_t cardorder[52] = { 35, 39, 21, 3, 0, 34, 4, 40, 22, 50, 47, 29, 31, 1, 32, 8, 2,30, 37, 19, 5, 38, 6, 23,
            20, 15, 41, 44, 27, 26, 14, 28, 33, 10, 11, 49, 13, 46, 36, 25, 18, 45, 43, 12, 16, 24, 48, 51, 42, 7, 17, 9 };
        my_srandom(9999);
        std::vector<uint8_t> deck(52);
        my_srandom(9999);
        shuffle(deck);
        for(auto j = 0; j < 52; j++) EXPECT_EQ(deck[j],cardorder[j]);
        //however, we expect the DEAL to be from the right, so it'd go 9, 17, 7, 42, ...
        //in fact let's unit test that
    }

    TEST(CribbageTest,Deal10FromShuf9999) {
        uint8_t dealorder[10] = { 9, 17, 7, 42, 51, 48, 24, 16, 12, 43 };
        my_srandom(9999);
        std::vector<uint8_t> deck(52);
        my_srandom(9999);
        shuffle(deck);
        for(auto j = 0; j < 10; j++) {
            EXPECT_EQ(deal_card(deck),dealorder[j]);
            EXPECT_EQ(deck.size(),52-(j+1));            //clunky but sort of readable, deck shrinks by 1 per card dealt
        }
    }

    //test cut: 10 card deck from 10..19, cut at index 6
    // but... now we count from the right? so index 6 is really 6 from the end
    // python semantics are now consistent
    TEST(CribbageTest,DeckCutTest) {
        uint8_t postcut_deck[10] = {14, 15, 16, 17, 18, 19, 10, 11, 12, 13 };
        std::vector<uint8_t> deck;
        deck.reserve(52);
        for(auto j=0;j<10;j++) deck.push_back(10+j);
        cut(deck,6);
        for(auto j=0;j<10;j++) EXPECT_EQ(deck[j],postcut_deck[j]);
   }
}

int main(int argc, char *argv[]) {


    // real testing main starts here
    ::testing::InitGoogleTest();
    RUN_ALL_TESTS();
}
