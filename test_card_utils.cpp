#include <stdio.h>
#include <iostream>
#include <string>
#include "card_utils.h"
#include "cribbage_core.h"
#include "cribbage_player.h"
#include "gtest/gtest.h"
#include "plat_io.h"

using namespace cardutils;
using namespace cribbage_core;

// need some globals in order to use the classes - gross but there it is
extern CardUtils cu;
extern Cribbage cr;

// Step 2. Use the TEST macro to define your tests.
//
// TEST has two parameters: the test case name and the test name.
// After using the macro, you should define your test logic between a
// pair of braces.  You can use a bunch of macros to indicate the
// success or failure of a test.  EXPECT_TRUE and EXPECT_EQ are
// examples of such macros.  For a complete list, see gtest.h.

// testing random first 10! seeded with 9999
// ================================================================

TEST(CardUtilsTest, VpokRandomFirst10From1337d00d) {
  // vpok random! First 10 are
  uint32_t vrandfirst[10] = {0xC46EB208, 0xB3C52DC7, 0x661E907A, 0xB576E591,
                             0x3E1961BC, 0x0C05D1EB, 0xAA513E4E, 0x57003155,
                             0x8C6652B0, 0x35C3464F};
  // which agree with my ancient PIC version!
  cu.v_srandom(0x1337d00d);
  for (auto j = 0; j < 10; j++) {
    EXPECT_EQ(cu.v_random(), vrandfirst[j]);
  }
}

// let's do ten million random_at_mosts and see if any wander out of bounds
// NOT CONCLUSIVE, just checks if the min and max are within the expected
// min-max range very suggestive, though, if ten million >> expected max
TEST(CardUtilsTest, RandomAtMost3333TenMReps) {
  uint32_t maxy = 0, minny = 0xFFFFFFFF, expmin = 0, expmax = 3333;
  cu.v_srandom(0x1337d00d);
  for (auto j = 0; j < 10000000; j++) {
    auto x = cu.random_at_most(expmax);
    if (x < minny) minny = x;
    if (x > maxy) maxy = x;
  }
  // plprintf("Minny = %d, maxy = %d\n",minny, maxy);
  EXPECT_LE(maxy, expmax);
  EXPECT_GE(minny, expmin);
}

TEST(CardUtilsTest, RandomAtMostMaxTooBig) {
  cu.v_srandom(0x1337d00d);
  auto x = cu.random_at_most(cu.RANDOM_MAX+1);
  EXPECT_EQ(x,cu.RANDOM_ERROR);
}

// card basics tests
// ========================================================================================

// test that card -> string -> card works for all cards
TEST(CardUtilsTest, StrcardCardstrAllLegit) {
  std::string cardstr;
  card_t outcard;
  for (card_t card = 0; card < 52; card++) {
    cardstr = cu.cardstring(card);
    outcard = cu.stringcard(cardstr);
    // plprintf("%2d => %s => %2d\n",card,cardstr.c_str(),outcard);
    EXPECT_EQ(card, outcard);
  }
}

TEST(CardUtilsTest, StrcardBadRank) {
  card_t outcard = cu.stringcard("Xh");
  EXPECT_EQ(outcard, cu.ERROR_CARD_VAL);
}

TEST(CardUtilsTest, StrcardBadSuit) {
  card_t outcard = cu.stringcard("Jx");
  EXPECT_EQ(outcard, cu.ERROR_CARD_VAL);
}

TEST(CardUtilsTest, CardstrBadNum) {
  std::string outstr = cu.cardstring(67);
  EXPECT_EQ(outstr,"ERROR");
}

// shuffle test for sameness with python implementation
TEST(CardUtilsTest, ShuffleTestFrom9999) {
  // generated by python shuffle after random seeded with 9999
  card_t cardorder[52] = {15, 9,  49, 14, 22, 31, 16, 13, 0,  50, 8,  47, 28,
                          11, 35, 2,  1,  12, 45, 7,  21, 23, 6,  17, 34, 37,
                          4,  41, 36, 40, 32, 38, 51, 19, 39, 46, 27, 10, 29,
                          26, 48, 33, 20, 30, 3,  44, 24, 42, 18, 25, 43, 5};
  std::vector<card_t> deck(52);
  cu.v_srandom(9999);
  cu.shuffle(deck);
  for (auto j = 0; j < 52; j++) EXPECT_EQ(deck[j], cardorder[j]);
  // however, we expect the DEAL to be from the right, so it'd go 9, 17, 7, 42,
  // ... in fact let's unit test that
}

TEST(CardUtilsTest, Deal10FromShuf9999) {
  card_t dealorder[10] = {5, 43, 25, 18, 42, 24, 44, 3, 30, 20};
  std::vector<card_t> deck(52);
  cu.v_srandom(9999);
  cu.shuffle(deck);
  for (auto j = 0; j < 10; j++) {
    EXPECT_EQ(cu.deal_card(deck), dealorder[j]);
    EXPECT_EQ(deck.size(), 52 - (j + 1));  // clunky but sort of readable, deck
                                           // shrinks by 1 per card dealt
  }
}

TEST(CardUtilsTest, DealFromEmptyDeck) {
  std::vector<card_t> deck;   //but don't put any cards in it
  card_t outcard = cu.deal_card(deck);
  EXPECT_EQ(outcard,cu.ERROR_CARD_VAL);
}

TEST(CardUtilsTest, DealFromOverlargeDeck) {
  std::vector<card_t> deck(56);
  std::fill(deck.begin(),deck.end(),0);
  card_t outcard = cu.deal_card(deck);
  EXPECT_EQ(outcard,cu.ERROR_CARD_VAL);
}

// test cut: 10 card deck from 10..19, cut at index 6
// but... now we count from the right? so index 6 is really 6 from the end
// python semantics are now consistent
TEST(CardUtilsTest, DeckCutTest) {
  card_t postcut_deck[10] = {14, 15, 16, 17, 18, 19, 10, 11, 12, 13};
  std::vector<card_t> deck;
  deck.reserve(52);
  for (auto j = 0; j < 10; j++) deck.push_back(10 + j);
  cu.cut(deck, 6);
  for (auto j = 0; j < 10; j++) EXPECT_EQ(deck[j], postcut_deck[j]);
}

//  171|      1|  if (deck.size() < 2 || index < 1 || index > deck.size() - 1) {
//  172|      0|    printf("Hey illegal deck or index\n");
//  173|      0|    return;  // no effect if illegal index or degenerate deck
//  174|      0|  }

TEST(CardUtilsTest, DeckCutErrorIndexTooLow) {
  std::vector<card_t> deck(52);
  cu.v_srandom(9999);
  cu.shuffle(deck);
  std::vector<card_t> outdeck;
  std::copy(deck.begin(), deck.end(), std::back_inserter(outdeck));
  cu.cut(deck,0);     // should have no effect
  EXPECT_EQ(deck,outdeck);
}

TEST(CardUtilsTest, DeckCutErrorIndexTooHigh) {
  std::vector<card_t> deck(52);
  cu.v_srandom(9999);
  cu.shuffle(deck);
  std::vector<card_t> outdeck;
  std::copy(deck.begin(), deck.end(), std::back_inserter(outdeck));
  cu.cut(deck,99);     // should have no effect
  EXPECT_EQ(deck,outdeck);
}

TEST(CardUtilsTest, DeckCutErrorDeckTooShort) {
  std::vector<card_t> deck = { 51 };
  std::vector<card_t> outdeck = { 51 };
  cu.cut(deck,1);     // should have no effect
  EXPECT_EQ(deck,outdeck);
}
